# MPT树

> 问题1:现在有\(cat,"xx"\),\(ca,"xx"\),\(doge,"xx"\),\(dog,"xx"\),\(test,"xx"\)这些键值对需要存储。  
> 那么可以用几种方法，map,trie树。  
> 1. 可以看到map其实太大了，如果有1000万个键值对，太占空间了  
> 2. trie树的每个节点都要至少26个node大小，具体可见 [trie树Java实现](http://xxxx)

于是有人研究出了mpt树这种数据结构，他的体积更小，具体如下

> 如果按照trie树的思路，一个byte需要256个节点数据的大小，但是现在
>
> > 如果将一个byte一分为2，2个四个bits,粗略的估计一下：这样就可以用16+16=32 个大小来表示,远小于256，（若一直拆分成8个bits不是空间更小吗？但是这样子查找的效率就会很低了，8个bits要查找8次，但是2个4bits只需要查找2次，所以比较合理的就是将一个byte分为2个4bits）
>
> 我们实际使用中发现，如果每个分叉都用16节点的形式，也是很浪费空间的，比如  
> 现在有 636174 （cat的16进制显示），需要6\*16个节点，但其实只有最后一个节点才存储"xx"这个值，所以要想不浪费空间，得遵循原则y\(1\):若有公共路径，则合并。

在讲真正的实现算法之前，先抛出一个问题，以

> 6 3 6 1    `例子(1)`  
> 6 4 6 f  
> 为例，若3和4之间形成了分叉，那么作为公共路径的6在真正存储的时候存储为0x06,这时有个问题：这个存储到底是06还是6，为了解决这个问题我们在规定，若是奇数个数字则前缀加上1，若是偶数，前缀加上00，在这种情况下变为0x16  
> 我们再规定若是  
> 1. 非终结节点，奇数=&gt; 0x1  
> 2. 非终结节点，偶数=&gt; 0x00  
> 3. 终结节点，奇数=&gt; 0x3  
> 4. 终结节点，偶数=&gt; 0x20  
> `例子(1)`最终成为  
>     0x16 分叉节点  
>     0x2061 0x206f  
> 这样规定有一个好处，在下面讲具体的算法时会讲解到

插入算法是说在某一节点node上插入一个\(key,value\)

```java
* node为空，则直接将(key,value)直接进行编码存储
* 若node 长度为2，则可以将key与node.k比较，若完全相等，则覆盖掉node.v
      若相等的长度<node.k.length，说明可以分叉，构造前缀和分叉节点
      若长度=node.k.length,说明需要在node.v上继续插入
* 若node 长度为17，则在分叉的node.k[key[0]]上继续插入
```

删除算法就是在某一个节点上删除一个key的东西

```java
* node或key为空，则直接将node返回
* 若node 长度为2，则可以将key与node.k比较，若完全相等，则返回""
      若相等的长度<node.k.length，说明没有这种节点
      若长度=node.k.length,说明需要在node.v上继续删除，删除返回的值需要与当前前缀合并，若为2，则合并长度，若为17则合并前缀
* 若node 长度为17，则在分叉的node.k[key[0]]上继续删除，但是要判断，若删除后只剩分叉16的数据，则直接构造返回，若还剩2个分叉则直接返回，若还剩一个分叉则要合并后再返回。
```

算法注意点：当你存储时是按照byte的nibble方法存储，前缀表示终节点和非终节点与奇数或偶数，但是当你比较的时候你是按照byte的nibble去掉前缀，只有后缀的形式来保存的。

### Java Code中需要注意的一些东西

1. 为什么要有Value? 因为直接object对象操作功能太少，所以做一层封装方便函数操作。
2. copyNode感觉没有必要：是的
3. copyNode时的对象模型，17分叉节点变了，但是指向的Value对象没有变
4. mockdb有什么用？其实mockdb才是真正存储数据的地方，cache只是一层缓存而已。
5. comparable的原理是什么？ 自己减去别人则为生序，别人减去自己则为降序！
6. byte&0xff有什么用？&是针对int做的，所以他将变为  0xfffffff0\(若第一位为1时\)&0x000000ff
7. new BigInteger\(1, asBytes\(\)\)何解？1表示byte转化的数据要为正数
8. Java的isPrimitive有何作用，确定array的元素的类型不是九大基本类型，应该是object类型
9. RLP encode是怎么做的？
10. >>>是右移，不足部分补充0
11. 



